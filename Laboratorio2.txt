%-----------------------------------Imagenes de prueba-----------------------------------
/* 
pixbitd( 0, 0, 1, 10, PA), pixbitd( 0, 1, 0, 20, PB), pixbitd( 1, 0, 0, 30, PC), pixbitd( 1, 1, 1, 4, PD), image("#FFFFFF", 2, 2, [PA, PB, PC, PD], I)
pixhexd(0, 0,"asdf",1,PA), pixhexd(0, 1, "asddf", 20, PB), pixhexd(1, 0,"adsf",30,PC), pixhexd(1, 1,"hgda",50, PD), image("", 2, 2, [PA, PB, PC, PD], I)
pixrgbd( 0, 0, 10, 10, 10, 10, PA), pixrgbd( 0, 1, 20, 20, 20, 20, PB), pixrgbd( 1, 0, 30, 30, 30, 30, PC), pixrgbd( 1, 1, 40, 40, 40, 40, PD), image("", 2, 2, [PA, PB, PC, PD], I)
*/



%-----------------------------------Constructores-----------------------------------

%pixbit-d
%Entrada: Posicion x, Posicion y, Bit, profundidad
%Salida: [Posicion x, Posicion y, Bit, profundidad]

pixbitd(X,Y,Bit,D,[X,Y,Bit,D]):-
    integer(X),
    integer(Y),
    Bit = 0 ; Bit = 1,
    integer(D).


%pixbit-d
% Dominio: Posicion x(int) , Posicion y(int) , Canal R(int) , Canal G(int) , Canal B(int) ,profundidad
%Recorrido: [Posicion x, Posicion y, Canal R, Canal G, Canal B, profundidad]

pixrgbd(X,Y,R,G,B,D,[X,Y,R,G,B,D]):-
    integer(X),
    integer(Y),
    between(0,255,R),
    between(0,255,G),
    between(0,255,B),
    integer(D).

%pixbit-d
%Entrada: Posicion x, Posicion y, Hex, profundidad
%Salida: [Posicion x, Posicion y, Hex, profundidad]

pixhexd(X,Y,Hex,D,[X,Y,Hex,D]):-
    integer(X),
    integer(Y),
    string(Hex),
    integer(D).

%2) Image
%Entrada: "Color_Comprimido", Ancho, Alto, [Lista de pixeles]
%Salida: [Color_Comprimido,Ancho,Alto,[Lista de pixeles]]

image(Color_Comprimido,Ancho,Alto,[H|T], [Color_Comprimido,Ancho,Alto,[H|T]]):-
    string(Color_Comprimido),
    integer(Ancho),
    integer(Alto).
%-----------------------------------Selectores-----------------------------------
getAlto([_,Alto,_,_], Alto).
getAncho([_,_,Ancho,_],Ancho).
getColor_Compresed([Color|_],Color).
getPixels([_,_,_,[H|T]], [H|T]).


getx([X|_], X).
gety([_,Y|_], Y).

getBit([_,_,Bit,_],Bit).
getHex([_,_,Hex,_],Hex).
getR([_,_,R,_,_,_] , R).
getG([_,_,_,G,_,_] , G).
getB([_,_,_,_,B,_] , B).
getDbithex([_,_,_,D],D).
getDrgb([_,_,_,_,_,D] , D).

%-----------------------------------Modificadores-----------------------------------
setAlto([Color,_,Ancho,[H|T]], NewAlto, [Color,NewAlto,Ancho,[H|T]]):-
    integer(NewAlto).
setAncho([Color,Alto,_,[H|T]], NewAncho, [Color,Alto,NewAncho,[H|T]]):-
    integer(NewAncho).
setColor_Compressed([_,Alto,Ancho,[H|T]],NewColor, [NewColor,Alto,Ancho,[H|T]]):-
    string(NewColor);
    integer(NewColor).
setPixels([Color,Alto,Ancho,_], [NewH|NewT], [Color,Alto,Ancho,[NewH|NewT]]).
          

setx([_|T], NewX, [NewX|T]):-
    integer(NewX).
sety([X,_|T], NewY, [X,NewY|T]):-
    integer(NewY).
setbit([X,Y,_,D], NewBit, [X,Y,NewBit,D]):-
    NewBit = 0 ; NewBit = 1.
sethex([X,Y,_,D], NewHex, [X,Y,NewHex,D]):-
    string(NewHex).
setr([X,Y,_,G,B,D], NewR, [X,Y,NewR,G,B,D]):-
    integer(NewR).
setg([X,Y,R,_,B,D], NewG, [X,Y,R,NewG,B,D]):-
    integer(NewG).
setb([X,Y,R,G,_,D], NewB, [X,Y,R,G,NewB,D]):-
    integer(NewB).   
setd_bithex([X,Y,Color,_],NewD, [X,Y,Color,NewD]):-
    integer(NewD).
setd_rgb([X,Y,R,G,B,_], NewD, [X,Y,R,G,B,NewD]):-
    integer(NewD).
%-----------------------------------Funciones----------------------------------
%3)imageIsBitmap
%Dominio: image
%Recorrido: boolean
imageIsBitmap([_,_,_,[H|_]]) :-
    pixbitd(_,_,_,_, H ).


%4)imageIsPixmap
%Dominio: image
%Recorrido: boolean
imageIsPixmap([_,_,_,[H|_]]) :-
    pixrgbd(_,_,_,_,_,_, H ).

%5)imageIsHexmap
%Dominio: image
%Recorrido: boolean
imageIsHexmap([_,_,_,[H|_]]) :-
    pixrgbd(_,_,_,_, H ).

%6)imageIsCompressed
%Dominio: Image
%Recorrido: Boolean
%Descripcion: Como se define en el Tda imagen que el primer elemento es el string
%del color comprimido, si el string es vacÃ­o significa es no ha sido comprimida.

imageIsCompressed([Color|_]):-
                  Color \= "" .

%7) imageFlipH
%Dominio: Imagen
%Recorrido: Imagen
%imagenFlipH([Color,Alto,Ancho,[H|T]], [Color,Alto,Ancho,[H|T]]):-
 

imageFlipH([Color,Alto,Ancho, Pixeles], [Color,Alto,Ancho, NewPixeles]):-
    maplist(pixelFlipH(Alto),Pixeles,NewPixeles).
                          
    
pixelFlipH(Alto, [X,Y|T] ,[X,NewY|T]):-
    NewY is (Alto-1)-Y.

%(8 imageFlipV
%Dominio: Imagen
%Recorrido: Imagen
imageFlipV([Color,Alto,Ancho, Pixeles], [Color,Alto,Ancho, NewPixeles]):-
    maplist(pixelFlipV(Ancho),Pixeles,NewPixeles).

pixelFlipV(Ancho, [X,Y|T] ,[NewX,Y|T]):-
    NewX is (Ancho-1)-X.

%(9 Crop
%Dominio: image X x1 (int) X y1 (int) X x2 (int) X y2 (int) X image

imageCrop([Color, _, _, Pixeles],X1,Y1,X2,Y2 , [Color, NewAlto, NewAncho, NewPixeles]):-
    H is X2-X1,
    abs(H,Hf),
    NewAlto is Hf + 1,
    W is Y2-Y1,
    abs(W,Wf),
    NewAncho is Wf + 1,
    
    min(X1,X2, Xmin),
    max(X1,X2, Xmax),
    min(Y1,Y2, Ymin),
    max(Y1,Y2, Ymax),
	include(dentro_de_margen(Xmin,Xmax,Ymin,Ymax),Pixeles, Pixelesfiltred),
	maplist(cambio_cords_crop(Xmin,Ymin),Pixelesfiltred,NewPixeles).
    
    
cambio_cords_crop(Xmin,Ymin,Pixelin,Pixelout):-
        getx(Pixelin,X),
        gety(Pixelin,Y),
        NewX is X-Xmin,
        NewY is Y-Ymin,
    	setx(Pixelin, NewX, P1),
    	sety(P1,NewY, Pixelout).
        
        
        
        
dentro_de_margen(Xmin,Xmax,Ymin,Ymax,Pixel):-
    getx(Pixel,X),
    gety(Pixel,Y),
    (X>=Xmin, X=<Xmax),
    (Y >= Ymin, Y =< Ymax).


    
    
min(Int1, Int2, Int3):-
    (Int1 < Int2, Int3 = Int1);
    (Int1 > Int2, Int3 = Int2);
    (Int1 = Int2, Int3 = Int2).

max(Int1, Int2, Int3):-
    (Int1 > Int2, Int3 = Int1);
    (Int1 < Int2, Int3 = Int2);
    (Int1 = Int2, Int3 = Int2).

abs(Intin, Intout):-
    (Intin >= 0, Intout = Intin);
    (Intin < 0, Intout is Intin * -1).

